<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Help" xml:space="preserve">
    <value>※戻り値は全て"=\n {戻り値}"の形式で出力

quit
内容:プログラム終了
引数:無し
エラー:無し
戻り値 : 無し

protocol_version
内容：プロトコルバージョンを取得する
引数：無し
エラー：無し
戻り値：プロトコルバージョンの番号

name
内容：プログラム名の取得
引数：無し
エラー：無し
戻り値：プログラム名

version
内容：プログラムバージョンの番号の取得
引数：無し
エラー：無し
戻り値：バージョン番号

clear_board
内容：盤面をクリアする
引数：初期配置のタイプ "cross", "parallel", "original"のうちのどれかから選択
エラー：無し
戻り値：無し

play
内容：黒石を指定した座標に着手する
引数：色 座標
エラー：不正な着手が行われたとき、"? illegal move"と出力
        不正な座標が指定されたとき、"? invalid color or coordinate"

fixed_handicap
内容：固定位置に置き石を配置
引数：置き石数
エラー：不正な置き石数 "? board not empty"と出力
		整数以外の引数が指定された場合は "? handicap not an integer"と出力
戻り値：石を配置した座標リスト

loadsgf
内容：SGFファイルを読み込み、石を配置する
引数：ファイル名 
      手数 or 座標
戻り値：次に着手を行うべき石の色
エラー：ファイルが存在しないときは "? cannot open or parse '{ファイル名}'" と出力
	SGFファイルの解析に失敗した時は "Empty file?" と出力

genmove
内容：指定した色の次の一手を生成し、それを着手する。
引数：色
エラー：
不正な色を指定されたとき、"? invalid color" と出力
戻り値：座標
        パスの場合は"PASS"と出力
	投了の場合は"resign"と出力

reg_genmove
内容：指定した色の次の一手を生成する
引数：色
エラー：不正な色が指定されたとき、"? invalid color"と出力
戻り値：座標
　　　　パスの場合は"PASS"と出力

undo
内容：着手を一手戻す
引数：無し
エラー：一手も打たれていない場合は "? cannot undo"と出力

time_settings
内容：持ち時間を指定する
引数：持ち時間
　　　秒読み時間
　　　秒読み回数
エラー：構文エラーの際は "? not there integers"と出力

final_score
内容：終局した時のスコアを計算する
引数：無し
戻り値：スコア（SGFフォーマット）

showboard
内容：現在の盤面の情報を出力する
引数：無し
エラー：無し
戻り値：盤面情報

help
利用可能な全てのコマンドのリストを取得する
引数：無し
エラー：無し
戻り値：コマンド

know_command
内容：指定したコマンドが利用可能かを返す
引数：コマンド名
エラー：無し
戻り値：コマンドが存在するとき "true"
	コマンドが存在しないとき "false"</value>
  </data>
</root>